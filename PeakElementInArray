package arrays;

public class BinarySearchLec {
    /*
     0     1    2    3   4   5   6    7      8
    [23 , 56 , 67 , 78 ,80, 83 , 90 , 110 , 780]
                            l h                

    target = 83
    mid = l+h = 0+8 = 8/2 = 4 (l+h)/2
    arr[mid] = arr[4] = 80

    80<target

    h = 8
    l = 5

    (8+5)/2 = 13/2 = 6.5 = 6

    90>target
    l = 5
    h = mid -1 , 6-1 = 5

    mid = 5+5 = 10 /2 = 5 


     arr[mid] < target

     h = 8
     l = 5 , mid+1

     arr[mid] > target

     h = mid -1



   





1. Peak Element in an Array


A Peak Element is an index i such that:

arr[i] >= arr[i - 1]  AND  arr[i] >= arr[i + 1]



 Array may contain multiple peaks
 Binary Search guarantees finding any one peak

Example
arr = [1, 3, 20, 4, 1, 0]

Peak → 20 (index 2)

Visual Understanding

Think of the array like a mountain range, not one big mountain.

        20
      /    \
  1 → 3     4 → 1 → 0

  Another example
arr = [1, 3, 2, 5, 4, 7, 6]


Peaks: 3, 5, 7

Binary Search may return any.

Edge Case: Strictly Descending Array
arr = [9, 8, 7, 6, 5, 4, 3, 2]


Peak = first element, because it has no left neighbor AND
9 > 8

       0   1  2   3  4  5
arr = [1, 3, 20, 4, 1, 0]

i. find mid , if mid is answer ?
ii. if not , move to thec left part or right 

l = 0 
h = 5
mid = (0+5)/2 = 5/2 = 2
arr[mid] = 20

arr[mid-1] = 3
arr[mid+1] = 4

20>3 && 20>4 ---20
       0  1  2   3    4   5


arr = [1, 3, 4  , 20 , 1, 0]

mid = 2

arr[mid] = 4 

4>3 , true
4>20 , false



a




     */

    public static void main(String[] args){


        int[] arr_ = {1, 3, 2, 5, 4, 7, 6};
       

        System.out.println("Peak element index: "+peakElement(arr_));

        
    }


    
    public static int peakElement(int[] arr){
        int n = arr.length;

        if(arr[0]>arr[1]) return 0;
        if(arr[n-1]>arr[n-2]) return n-1;

        int l = 1;
        int h = n-2;
        while(l<=h){
            int mid = (l+h)/2;
            if(arr[mid]>arr[mid-1] && arr[mid]>arr[mid+1]){
                return mid ;
            }
            else if (arr[mid-1]>arr[mid]){
                h = mid -1;
            }else{
                l = mid+1;
            }
        }

       return -1 ; 
    }
   
}
